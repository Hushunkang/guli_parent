对于关系型数据库而言，受伤害比较大的操作就是频繁的查询操作
在关系型数据库里面，如果频繁查询的数据但是这些数据比较固定不经常更新
就可以把这些数据摘出来
放到缓存里面，减轻数据库被访问的压力和负担

对于关系型数据库而言，事务的四大特性acid

nosql一般能做哪些事情
1、易扩展
nosql数据库种类繁多，但是一个共同的特点都是去掉关系型数据库的关系型特性
数据之间无关系，这样就非常容易扩展，也就在无形之间，在架构的层面上带来了可扩展的能力
2、大数据量高性能（一般地，redis一秒钟写可以8w次，读可以11w次，不管咋说，redis的读写能力非常强悍）
nosql数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀
这得益于它的无关系性，数据库的结构简单
一般地，mysql使用查询缓存，每次表的更新缓存就失效，是一种大粒度的缓存
针对交互频繁的web2.0的应用中，mysql的查询缓存效率不高，而nosql的缓存是记录级别的，是小粒度的缓存
是一种细粒度的缓存，所以nosql在这个层面上来说就要性能高很多了
3、多样灵活的数据模型
nosql无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式，而在关系型数据库里
增删字段是一件非常麻烦的事情，如果是非常大数据量的表，增加字段简直就是一个噩梦

比较传统的rdbms和nosql
rdbms
- 存储高度组织化结构化的数据
- 结构化查询语言（sql）
- 数据的结构和真正的数据都存储在单独的表中（表的结构，表的数据）
- 数据操纵语言，数据定义语言
- 严格的一致性
- 基础事务
nosql
- 代表着不仅仅是sql
- 没有声明性查询语言
- 没有预定义的数据的结构
- 键值对的方式存储数据，列存储，文档存储，图形数据库等
- 最终一致性，而非acid属性
- 非结构化的数据和不可预知的数据
- nosql数据库的CAP+BASE
- 高性能、高可用性、可伸缩性

如果你就想干一件事，专精于一件事，高速缓存的，就用memcached
如果你想expert in one and good at many things，就用redis

怎么玩redis？？？就这三个东西，键值对、cache、persistence

互联网时代的3v+3高
3v指的是大数据时代下的海量（Volume）、多样（Variety）、实时（Velocity）
说明：这实时一般做不到绝对的实时，都是准实时的
3高知道的是高并发、高性能（高可用）、高可扩
说明：高可扩指的是水平扩展，直接加机器，而不是垂直扩展，垂直扩展说白了就是强化机器的配置

当下的应用程序一般是搭配sql和nosql一起使用滴，各有用途

能在github上面向著名开源项目发pr，别人还通过了，说明你的技术功底非常强

多数据源（你所看到的文字、图片、音频、vcr等不可能统统放到mysql里面搞定，这些数据在不同的数据源里面）和多数据类型（文字、图片、音频、vcr等）的存储问题

技术的路上，找对方向和方法，坚持就会牛p，其它事情也一样

淘宝的商品波动性，热点高频词汇（比如情人节，rose就是高频词汇）就会被放到nosql里面（内存数据库、缓存数据库）

总结大型互联网应用（大数据量、高并发、多数据源和多数据类型）的难点和解决方案
借鉴jdbc的思想（面向接口编程），诞生了统一数据平台服务层UDSL，UDSL一统天下，只需要面向UDSL编程即可

分布式微服务架构的系统非常忌讳连接查询，高并发的操作不太建议有连接查询
适当的采取冗余字段的策略来避免关联查询，比如在商品表里面冗余商品类别名称这种不太会被经常改变的字段
但是要注意改变了商品类别名称要同步更新你的那个商品表，否则就是脏数据了
分布式事务是支持不了太多的并发的

聚合的数据模型常见的有：键值对模型、bson模型、列族模型、图形模型（这四种数据模型其实对应着nosql数据库的四大分类）
说明：列族模型说白了就是纵表，我们一般都是设置横表，详情谷歌搜索横表和纵表以及应用场景，图形模型典型例子就是复杂的人际关系

学习的相通和传递性，还是那句话，多学原理、思想、方法、本质不要去学表面现象

没有那么多新的技术，切记新从旧始，思想相通，你抄袭我的，我抄袭你的，变个皮让表面现象不一样，本质是一样的

CAP定理
在理论计算机科学中，CAP定理，又被称作布鲁尔定理
它指出对于一个分布式计算系统来说
不可能同时满足以下三点
一致性、可用性、分区容错性
根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项，即CAP的3进2
理解CAP理论的最简单方式是想象两个节点分处分区两侧
允许至少一个节点更新状态会导致数据不一致，即丧失了C性质

提高系统的并发能力的一种常见策略，集群嘛，通过负载均衡机制提高系统并发能力，原来系统并发的能处理N1个请求，现在系统并发的能处理N2个请求（N2>>N1）

分布式和集群简介
分布式系统（distributed system）是指由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成
分布式系统是建立在网络之上的软件系统，正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性
因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件
分布式系统可以应用在在不同的平台上如：PC、工作站、局域网和广域网上等
通俗的理解分布式即不同的多台服务器上面部署不同的服务模块
他们之间通过RMI/RPC之间通信和调用
对外提供服务和组内协作
集群（人多力量大）指的是不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问

系统架构一般分为传统的单一架构的系统和分布式微服务架构的系统

分布式系统的CAP定理
分布式系统（distributed system）正变得越来越重要，大型网站几乎都是分布式的
分布式系统的最大难点，就是各个节点的状态如何同步
CAP定理是这方面的基本定理，也是理解分布式系统的起点
分布式系统的三大指标
- Consistency: 强一致性指的是所有节点都能在同一时间返回同一份最新的数据副本
- Availability: 可用性指的是每次请求都能够返回非错误的响应（说白了数据暂时不一致不要紧，你先给我能用，应用别蹦了）
- Partition tolerance: 分区容错性指的是服务器间的通信即使在一定时间内无法保持畅通也不会影响系统继续运行
说明：分布式系统的分区容错性通俗的理解，允许你出错，出啥错，就是分布式系统里面的两个服务器节点可能由于一些原因，导致它们之间没办法通信，这是很正常的问题，因此你分布式系统必须满足P
参照资料：https://juejin.im/post/5da44bcbe51d4578440fe63a
在高并发的情况下，正常的哈，非常难实现（为什么难，看上面的帖子你就明白了）数据的强一致性，通俗的理解就是说，表示同一个事物的数据在分布式系统中的两个数据库节点中不一样
在高并发之后，然后再去实现数据的强一致性即可，说白了就是分布式系统中数据的最终一致性（可以理解为弱一致性）
一定要理解，为什么强一致性和可用性为什么不能同时满足，数据库集群里面的辣个同步操作是要锁住被同步节点的读写操作滴，此时此刻你的那个被同步节点就不可用辣

互联网里面99.999999999999%的应用其实都不是绝对的实时，而是准实时
比如说某人发了一条新浪微博，你一直刷新微博，眼睛一直盯着微博，然后你看到了这个人发的微博
但这并不意味着你看到这条微博的时刻就是别人微博发送成功这条微博的那个时刻，往往会间隔几秒乃至十几秒
这就是准实时，底层的原理不就是
数据的最终一致性（数据的弱一致性）+A+P，其实绝大多数互联网应用也是妥协到这种策略

nosql数据库的CAP+BASE
CAP：C表示强一致性（Consistency）、A表示可用性（Availability）、P表示分区容错性（Partition Tolerance）
BASE：BA表示基本可用（Basically Available）、S表示软状态（Soft State）、最终一致性（Eventually consistent）

redis是单进程的，redis默认有16个数据库，redis默认端口号是6379
详情参照redis杂项基础知识.jpg

redis数据类型（redis将memcached干掉了的一个重要原因也是因为redis支持的数据类型更加丰富）
1、String（字符串）
2、Hash（类似于java中的Map）
3、List（列表）
4、Set（集合）
5、Zset（sorted set：有序集合）
说明：Zset只是在Set的基础上加了一个score值，Set是sadd k1 v1 v2，Zset是zadd k1 score1 v1 score2 v2

哪里去获取redis数据类型的命令操作，参照官方文档，当然不仅限官方文档，菜鸟教程各种地方也找的到学习资源，找资源也是一种能力，多摸索



