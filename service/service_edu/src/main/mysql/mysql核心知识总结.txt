=============mysql为什么使用B+树（加强版的多路平衡查找树）这种数据结构作为索引=============

=============mysql如何避免索引不失效写出高效sql=============
口诀（编写业务sql尽可能利用到建立的索引，不要让索引失效而产生FULL TABLE SCAN）
全值匹配我最爱，最左前缀要遵守（最左前缀：即是下一句口诀，带头大哥不能死，中间兄弟不能断）
带头大哥不能死，中间兄弟不能断（细节：把握这个原则的前提下，编写sql时带头大哥和兄弟列的顺序是可以无序的）
索引列上少计算，范围之后全失效
like百分写最右，覆盖索引不写星
不等空值还有or，索引失效要少用
var引号不可丢，SQL高级也不难
参考
https://blog.csdn.net/zsx157326/article/details/79406491

=============mysql查询优化=============
1、小表驱动大表（小表的查询结果当成大表的查询已知条件，来求结果）
带有in的子查询是子查询驱动了父查询
带有exists的子查询是父查询驱动了子查询
参考
https://blog.csdn.net/codejas/article/details/78632883
2、where子句和order by子句的并集满足最左前缀
3、order by子句满足最左前缀
4、order by子句尽量避免FileSort
5、泛泛的讲（因为表分区的方式有很多），按照表中的特定的字段的值对表进行分区，提高查询效率
6、待发掘新的骚操作(*￣︶￣)
参考
https://www.jianshu.com/p/1cdd3e3c5b3c

=============mysql分表分库表分区=============
分表、分库、表分区（架构的一般的演变顺序，先分表，然后分库，最后表分区）
分表：单表容量超过了500w左右考虑分表，一般按照id来分表，这是水平的方式来分表
分库：泛泛的讲，你不分库，对于大型的微服务网站而言，你所有请求怼到一个库上面，库不挂才怪，一般采取垂直的方式来分库
说明：通俗解释下啥叫垂直的方式来分库，就是按照企业项目的功能模块来分不同的库
一个功能模块对应一个库，一个库放在一个物理服务器上面，大概意思是这样的，实际情况更加复杂
这是架构问题，要结合具体的业务场景来搞架构，不要把知识学死了
还有就是比较好的一个数据库中间件mycat可以解决相关问题
企业项目一般采用水平分表+垂直分库的设计方案
参考
https://juejin.im/entry/5b5eb7f2e51d4519700f7d3c
表分区：泛泛的讲（因为表分区的方式有很多），按照表中的特定的字段的值对表进行分区

=============浅谈mysql锁=============
锁有千千万，但是它的业务目标只有一个，一般用于高并发场景下，并发事务，数据安全问题，即在高并发场景下，同一个数据必须在各个事务内部必须是一致的！！！
mysql锁按照锁粒度来分类可以有行锁和表锁，innodb存储引擎最细粒度的锁为行锁，myisam存储引擎最细粒度的锁为表锁
InnoDB锁模式
InnoDB实现了以下两种类型的行锁
即共享锁和排它锁
为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种类型的意向锁都是表锁
即意向共享锁和意向排它锁

行锁偏向于解决并发写操作问题，表锁偏向于解决并发读操作问题

InnoDB加锁方法
意向锁是InnoDB自动加的，不需用户干预
对于INSERT、UPDATE、DELETE的sql语句，InnoDB会自动给涉及到的记录集加上排它锁，对于普通SELECT的sql语句，InnoDB不会加任何锁
数据库事务可以通过以下语句显式给涉及到的记录集加上共享锁或者排它锁
select ... lock in share mode//共享锁（能确保当前事务查询到的数据是最新的，但是当前事务不可以修改涉及到的记录集）
select ... for update//排它锁（也能确保当前事务查询到的数据是最新的，并且当前事务可以修改涉及到的记录集）
共享锁（读锁）：其它事务可以读操作，但不能写操作，共享锁会阻塞其它事务的写操作，但不会阻塞其它事务的读操作，当前事务不可以写操作，不可以读写其它表直到释放读锁
排它锁（写锁、独占锁）：其它事务不可以读写操作，排它锁会把其它事务的读写操作都阻塞掉，因此也叫独占锁，当前事务可以读写操作，不可以读写其它表直到释放写锁
for update的一般应用场景：高并发场景下并且必须保证同一个数据必须在各个事务内部必须是一致的，比如涉及到金额数据
说明：数据库事务、数据库会话、数据库连接对象是一一对应的关系，一定程度上看成同一个事物

mysql查看正在被锁定的表
show open tables where in_use>0;
查看进程列表
show processlist;
根据进程ID杀死进程
kill 进程ID;

=============浅谈mysql主从复制原理=============
从库（一般设计为多个，读库）会读取主库（一般设计为一个，写库）的binlog来进行数据同步，slave将master的binlog拷贝到它的中继日志
